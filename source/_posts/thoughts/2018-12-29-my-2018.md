---
layout:     post
title:      "My 2018 and New Year Resolution"
date:       2018-12-29
summary:    There are always some reflections every year. It came stronger than ever at the beginning of 2018. Partly as a result, it made the past year more unpredictable but productive.
categories: Thoughts
---

There are always some reflections at the end of every year. What did I do right? What have I done wrong? How could I correct and improve? However, they came stronger than ever at the beginning of 2018. It was never easy to say goodbyes when colleagues became friends, especially when the [departures were involuntary](https://techcrunch.com/2018/01/03/wi-fi-startup-eero-lays-off-30-employees/). There were shakeups, following by resets and fiercer soul searching. Luckily, at the end of the year, the company is still alive and becomes even stronger. Many of my friends are still here. I am still excited when I get up and go to work every day.

Using Golang in real-world projects was great. The extremely long "cursing period" reminded me how Python had spoiled me in all these years - I could not remember how many times that I cursed the Golang and asked why on earth certain things had to be in twisted ways. It made me cherish more about the developer-friendly languages and gave me peace of mind by knowing I had a last resort to solve a problem or prototype something quickly. On the other hand, I appreciated why Golang had those "quirky" idioms and that the designers of this language strived to find the tradeoffs between expressiveness and efficiency.

I was drawn to Golang by the communicating sequential processes, but it went down to my third favorite feature, even though it was arguably the most distinctive feature and did work much better than the asynchronous function calls. The top two features were both about data structure. First, it felt great writing in a language that is free from objects. I was never a big fan of OOP, though ironically I wrote plenty of objects in code on a daily basis. Data and functions should be enough to implement most of the algorithms. Objects were natural to express the design patterns, but they were also too easy to avoid overusing. Second, the interface provided a more rigorous API to a module. It emphasized more on the design patterns. One could still find innovative ways to abuse it, but it was much harder than native objects.

Migrating to Emacs might be the most far-reaching thing that happened to me this year. It was [tempting to me before](https://wqiong.com/programming/2016/06/26/emacs-progression-path/), but I never made the transition. Two things had played a decisive role - [Spacemace](http://spacemacs.org) and [Org mode](https://orgmode.org).

It started from years-long of searching for the *right* application to take notes and to write journals. I was picky about tools. In my opinion, a "usable" note application should have quite a few features, including integration with calendar, flexible formatting (multi-layers sections, itemize, enumerate, fonts like bold, italic, and so forth), links for URLs or other journal entries, plain text (for cross-platforms, version control, exporting to other formats, searching, batching processing, etc.), and a bit user friendly than Latex.

I felt so happy to find the Org-mode in Emacs eventually. I had been mocking Emacs for years that it was an operating system with a mediocre editor. Now that this operating system had everything I had asked for an even more out of the box ([built-in Git module](https://magit.vc), rendering and [spell checking](https://www.gnu.org/software/emacs/manual/html_node/emacs/Spelling.html) on the fly, [numerous useful keybindings](https://orgmode.org/orgcard.pdf), [running code within a doc](https://orgmode.org/worg/org-contrib/babel/), [spreadsheet](https://orgmode.org/manual/The-spreadsheet.html), [slides](https://orgmode.org/worg/org-tutorials/non-beamer-presentations.html), and so forth), I had eggs on my face. Need a web portal? Both Github and Gitlab had supported rendering the Org-mode in their repositories. As a result, it was possible to view the files in almost all devices that had shell and web browser. It was the *genuine* Cross-platform. Better still, I had a few colleagues whose go-to editor was the Emacs, so that I could have my weird questions answered in almost real-time. Their help made the transition much smoother.

At the beginning of 2018, I undertook a five-months cut and workout and lost 15 pounds. It was not dramatic but did give me a chance to push myself to do more exercise and eat healthier. I also took a couple of months of training in CrossFit. Though I still don't get the point of why people would count the reps of a workout in a stadium for competition, most of the movements are very useful to build a stronger body. It helps me find many overlooked muscle groups, which in turn gives me more boost and protection while playing tennis.

One thing that I'm proud of myself the most in 2018 is to resume reading on a daily basis. I've finished 15 books, including some textbooks of computer science, biographies about Steve Jobs, Phil Night, and Tom Brady, non-fiction about Oakland Athletics, Obama administration, Pixar, homo sapience, and the process of thinking, and some other goofy stuff such as the book *What if*. The reading itself calms me down in the environment full of distracting and fragmented information. More importantly, it magically converts my long and mundane morning commute into an exciting journey of the mind. I either learned something new or was merely amused by the experiences of other lives.

In the coming year, I hope my reading schedule can be *more structured*, especially before going to sleep and during the weekends. The selection of contents should also be more systematic. There are two directions to learn in general - the algorithm and the system. More often than not, I struggle to find a balance and end up wasting time without satisfactory results. I enjoy more while learning math and formal methods. They are challenging and exciting. One of the examples of the latter ones is the Linux kernel. The learning curve is steeper due to the system itself. It is immense and intricate. Hopefully, I can *finish* equal amount of books for both directions. Sometimes, it is more tempting to keep Netflix rolling especially after a day of exhausting work, but what my mind needs might be a stretching rather than resting. Also, I'd like to try more fictions. I've started *A Song of Ice and Fire* but never finished. In this case, it is easier to objectively criticize some lifeless theories than emotionally involved with a virtual character. At the end of the year, I'd be very happy if I finish the first two volumes of *The Art of Computer Programming*, along with *A Game of Thrones* and *A Clash of Kings* :) I'm sure I can find time to squeeze in some pointless bestsellers of the New York Times.

In 2019, there will be more uncertainties both at work and in my life. Many of them are out of my control. I wish I could find a solution for most of whatever comes along the way. More importantly, I can put the things that I've learned in 2018 and the past to use to become a bit stronger and wiser.

Stephen King tries to [write six pages per day](https://youtu.be/xR7XMkjDGw0) so that he has a rough estimate that a 360-page book is about two months worth of work. Assuming reading is about ten times easier than writing, plus all of the "more important" things in life, I should be able to read 20 to 60 pages a day, depending on which device and which font size of the book. The well-known bestseller author admitted that he was extremely fortunate and did not understand what he was doing. Nevertheless, he still set up a goal and achieved it on a daily basis. I should be able to do the same thing - estimate the workload, set up a viable plan, and stick to it.

Finishing this post with some inspiring words from [Gerald M. Weinberg](http://secretsofconsulting.blogspot.com/2017/10/where-do-old-programmers-go.html):

> If you’re good, you can do any of these things even at an advanced age, but you can’t just sit around waiting for someone to find you.  If you’re not good, then either get good (it’s never too late) or retire. We don’t need mediocre programmers, and we never did.
